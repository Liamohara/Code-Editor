import { app, dialog, ipcMain } from "electron";
import fs from "fs";
import path from "path";
import * as pty from "node-pty";

import Window from "./window";

// Allows TypeScript to use the magic constant that's auto-generated by Electron Forge's Webpack plugin.
declare const EDITOR_WINDOW_WEBPACK_ENTRY: string;
declare const EDITOR_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

class EditorWindow extends Window {
  private static instances = new Map<number, EditorWindow>();

  private interpreter: string;
  private ptyProcess: pty.IPty;
  private buffer = "";
  private bufferCmd: string;
  private bufferOut: string;
  private fileDir: string;

  constructor(darkMode: boolean, interpreter: string) {
    super(
      EDITOR_WINDOW_WEBPACK_ENTRY,
      EDITOR_WINDOW_PRELOAD_WEBPACK_ENTRY,
      darkMode
    );

    this.interpreter = interpreter;

    this.window.webContents.once("did-finish-load", () => this.initPty());

    this.window.once("show", () => this.eventEmitter.emit("show"));

    this.window.on("close", async (event) => {
      event.preventDefault();

      let canceled = 0;

      if (await this.isEdited()) {
        canceled = (
          await this.showWarningDialog(
            "Quit with unsaved changes?",
            "Closing this window will lose all unsaved changes. Close anyways?"
          )
        ).response;
      }

      if (!canceled) {
        this.window.destroy();
      }
    });

    const id = this.window.id;

    this.window.once("closed", () => {
      EditorWindow.instances.delete(id);
      this.ptyProcess = null;
    });

    EditorWindow.instances.set(id, this);
  }

  static fromID(id: number) {
    return EditorWindow.instances.get(id);
  }

  private initPty() {
    // Initialise node-pty process
    this.ptyProcess = pty.spawn(this.interpreter, [], {
      cwd: this.fileDir,
      handleFlowControl: true,
    });

    this.ptyProcess.onData((data) => {
      if (this.bufferCmd) {
        this.buffer += data;
        if (this.buffer === this.bufferCmd + "\n") {
          this.send("shell:stdout", this.bufferOut);
          this.bufferCmd = null;
          this.buffer = "";
        }
      } else {
        this.send("shell:stdout", data);
      }
    });

    this.ptyProcess.onExit(() => {
      this.send("shell:clear");
      this.initPty();
    });
  }

  writeToPty(data: string) {
    this.ptyProcess.write(data);
  }

  resetPty() {
    this.bufferOut = "";
    this.bufferCmd = "quit()\r";
    // Quits pty. Will restart automatically.
    this.writeToPty(this.bufferCmd);
  }

  async getFile(isEdited?: boolean) {
    const fileSelection = await this.showFileDialog();

    if (!fileSelection.canceled) {
      let canceled = 0;
      if (isEdited) {
        canceled = (
          await this.showWarningDialog(
            "Overwrite Current Unsaved Changes?",
            "Opening a new file in this window will overwrite your unsaved changes. Open this file anyway?"
          )
        ).response;
      }

      if (!canceled) {
        this.openFile(fileSelection.filePaths[0]);
      }
    }
  }

  private showFileDialog() {
    return dialog.showOpenDialog(this.window, {
      defaultPath: app.getPath("documents"),
      properties: ["openFile"],
      filters: [
        { name: "Python Files", extensions: ["py", "pyw"] },
        { name: "Text Files", extensions: ["txt"] },
        { name: "All Files", extensions: ["*"] },
      ],
    });
  }

  private showSaveDialog() {
    return dialog.showSaveDialog(this.window, {
      title: "Save File",
      defaultPath: app.getPath("documents"),
      filters: [
        { name: "Python Files", extensions: ["py", "pyw"] },
        { name: "Text Files", extensions: ["txt"] },
        { name: "All Files", extensions: ["*"] },
      ],
    });
  }

  private showWarningDialog(title: string, message: string) {
    return dialog.showMessageBox(this.window, {
      type: "warning",
      title,
      message,
      buttons: ["Yes", "Cancel"],
      defaultId: 0,
      cancelId: 1,
    });
  }

  private openFile(filePath: string) {
    const content = fs.readFileSync(filePath).toString();
    app.addRecentDocument(filePath);
    this.send(
      "file:open",
      path.basename(filePath),
      path.dirname(filePath),
      content
    );

    // Resets PTY Process to change shell working directory.
    this.fileDir = path.dirname(filePath);
    this.resetPty();
  }

  async saveFile(filePath: string, content: string) {
    if (!filePath) {
      filePath = (await this.showSaveDialog()).filePath;

      if (!filePath) return;

      fs.writeFileSync(filePath, content);
      this.openFile(filePath);
    } else {
      fs.writeFileSync(filePath, content);
    }

    this.send("title:update");

    return filePath;
  }

  async runFile(filePath: string, content: string) {
    let timeout = filePath ? 0 : 500;

    filePath = await this.saveFile(filePath, content);

    if (filePath) {
      // Waiting for shell to reset.
      setTimeout(() => {
        let fileName = path.basename(filePath);
        this.bufferOut = `% RUN ${fileName} %\r\n`;
        this.bufferCmd = `exec(open(r"${filePath}").read())\r`;
        this.writeToPty(this.bufferCmd);
      }, timeout);
    }
  }

  isEdited(): Promise<boolean> {
    return new Promise((resolve) => {
      this.send("file:is-edited");
      ipcMain.once("file:is-edited", (_event, isEdited) => {
        resolve(isEdited);
      });
    });
  }

  isFileOpen() {
    return new Promise((resolve) => {
      this.send("file:is-open");
      ipcMain.once("file:is-open", (_event, isFileOpen) => {
        resolve(isFileOpen);
      });
    });
  }
}

export default EditorWindow;
